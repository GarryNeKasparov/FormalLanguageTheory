*$FROM Test
$EXTERN Test;

$INCLUDE "Automata";

$ENTRY Go {
    = <Prout <Parse 1>>;
*    = <Prout
*        <Derivate ('b') ('or '('con '('rep '('or a '('con a b')))' '('con b '('rep b')))' '('rep b'))>>;

}

* (a|(ab))âˆ—b+

Parse {
    s.Stream
    , <Open 'r' s.Stream './tests/1.txt'> :
    , <Get s.Stream> : e.Regex
    , <Br 'Vars='> :
    , <Regex (() ()) e.Regex> : (Regex (e.Tree))
    , <Prout e.Tree> :
    , <Cp 'Vars'> : s.First e.Vars
    , <SymTable-Create> : t.Automata
    , <Br 'Automata='t.Automata> :
    , <ComputeDeriv s.First e.Vars (e.Tree) ()> :
    , <Cp 'Automata'> : t.Automata^
    = <Prout t.Automata>;
}

Regex {
    (e.Scanned) (e.Tree) ERR e.Msg = ((e.Scanned) (e.Tree)) ERR e.Msg;
    (() ()) (Term (e.Parsed)) e.Tokens
        = <Regex (Term (e.Parsed)) e.Tokens>;
    (() ()) e.Tokens = <Regex (() ()) <Term (() ()) e.Tokens>>;

    (Term (e.Tree)) '|'e.Tokens
        = <Regex (Term Binary ('or 'e.Tree)) e.Tokens>;
    (Term (e.Tree)) '#'e.Tokens
        = <Regex (Term Binary ('sfl 'e.Tree)) e.Tokens>;
    (Term (e.Tree)) e.Tokens = (Regex (e.Tree)) e.Tokens;

    (Term Binary (e.Tree)) (Regex (e.Parsed)) e.Tokens
        = <Regex (Term Binary Regex ( (e.Tree' 'e.Parsed) )) e.Tokens>;
    (Term Binary (e.Tree)) e.Tokens
        = <Regex (Term Binary (e.Tree)) <Regex (() ()) e.Tokens>>;

    (Term Binary Regex (e.Tree)) e.Tokens = (Regex (e.Tree)) e.Tokens;
    (Term (e.Tree)) e.Tokens = (Regex (e.Tree)) e.Tokens;
}

Normalize {
    ('or 'e.OutOr ('or 'e.InOr1' 'e.InOr2))
        = <Prout '(or 'e.OutOr '(or 'e.InOr1' | 'e.InOr2'))\n'
          Result':' '(or (or 'e.OutOr e.InOr1') 'e.InOr2')\n'>
        ('or '('or 'e.OutOr e.InOr1)' 'e.InOr2);
    e.Else = <Prout '\n'No rule e.Else '\n'> e.Else;
*    e.Else = e.Else;
}

Term {
    ((e.Scanned) (e.Tree)) ERR e.Msg = ((e.Scanned) (e.Tree)) ERR e.Msg;
    (() (e.Tree)) (Factor (e.Parsed)) e.Tokens
        = <Term (Factor (e.Parsed)) e.Tokens>;
    (() (e.Tree)) e.Tokens
        = <Term (() (e.Tree)) <Factor (() (e.Tree)) e.Tokens>>;

    (Factor (e.Tree))'|'e.Tokens = (Term (e.Tree)) '|'e.Tokens;
    (Factor (e.Tree))'#'e.Tokens = (Term (e.Tree)) '#'e.Tokens;
    (Factor (e.Tree))')'e.Tokens = (Term (e.Tree)) ')'e.Tokens;

    (Factor (e.Tree)) = (Term (e.Tree));
    (Factor (e.Tree)) e.Tokens
        = <Term (() (e.Tree)) <Factor (() (e.Tree)) e.Tokens>>;
}

Factor {
    ((e.Scanned) (e.Tree)) ERR e.Msg = ((e.Scanned) (e.Tree)) ERR e.Msg;

    (() ()) (Base (e.Parsed)) e.Tokens
    , <Prout tree ()' 'Parsed is' '(e.Parsed)' 'and tokens' 'e.Tokens> :
    , e.Tokens : {
        '*'e.Rest = <Factor (Base (('rep 'e.Parsed))) e.Rest>;
        '+'e.Rest = <Factor (Base (('con 'e.Parsed' '('rep 'e.Parsed)))) e.Rest>;
        e.Else = <Factor (Base (e.Parsed)) e.Tokens>;
    };

    (() (e.Tree)) (Base (e.Parsed)) e.Tokens
    , <Prout tree (e.Tree)' 'Parsed is' '(e.Parsed)' 'and tokens' 'e.Tokens> :
    , e.Tokens : {
        '*'e.Rest = <Factor (Base (('con 'e.Tree' '('rep 'e.Parsed)))) e.Rest>;
        '+'e.Rest = <Factor (Base (('con 'e.Tree' '('con 'e.Parsed' '('rep 'e.Parsed))))) e.Rest>;
        s.Char e.Rest = <Factor (Base (('con 'e.Tree' 'e.Parsed))) e.Tokens>;
        = <Factor (Base (('con 'e.Tree' 'e.Parsed)))>;
    };

    (() (e.Tree)) e.Tokens = <Factor (() (e.Tree)) <Base (() (e.Tree)) e.Tokens>>;

    (Base (e.Tree)) e.Tokens = (Factor (e.Tree)) e.Tokens;
}

Base {
    ((e.Scanned) (e.Tree)) ERR e.Msg = (e.Tree) ERR e.Msg;

    (() (e.Tree)) '(' e.Tokens = <Base ('(' (e.Tree)) e.Tokens>;

    ('(' (e.Tree)) (Regex (e.Parsed)) e.Tokens
        = <Base ('('Regex (e.Parsed)) e.Tokens>;
    ('(' (e.Tree)) e.Tokens
        = <Base ('(' (e.Tree)) <Regex (() ()) e.Tokens>>;

    ('('Regex (e.Tree)) ')' e.Tokens = <Base ('('Regex')' (e.Tree)) e.Tokens>;
    ('('Regex')' (e.Tree)) e.Tokens = (Base (e.Tree)) e.Tokens;

    (() (e.Tree)) s.Char e.Tokens = <Base (s.Char (e.Tree)) e.Tokens>;
    ('*' (e.Tree)) e.Tokens = (Base ('*')) e.Tokens;
    ('+' (e.Tree)) e.Tokens = (Base ('+')) e.Tokens;
    (s.Char (e.Tree)) e.Tokens
    , <IsAlpha s.Char> : {
        True = <AppendToVarList s.Char>
                (Base (s.Char)) e.Tokens;
        False = ((e.Tree)) ERR s.Char' 'does not belong to alphabet;
    };
    (() (e.Tree)) = (Base (e.Tree));
}

IsAlpha {
    s.Char
    , <Ord s.Char> : e.Ord
    , <Compare e.Ord <Ord '{'>> : {
        '-'
        , <Compare e.Ord <Ord '`'>> : {
            '+' = True;
            e.Else = False;
        };
        e.Else = False;
    };
}

AppendToVarList {
    s.Char
    , <Cp 'Vars'> : e.Vars
    , <IsIn s.Char (e.Vars)> : {
        True = ;
        False = <Br 'Vars='e.Vars s.Char>;
    };
}

IsIn {
    s.Char (e.VarsBegin s.Char e.VarsRest) = True;
    s.Char (e.Vars) = False;
}

Derivate {
    (s.Char) s.Char = eps;
*    (s.Char) (eps) = empty;
*    (s.Char) (empty) = empty;
    (s.Char) s.NotEqual = empty;
    (s.Char) ('rep 'e.Op)
    , <Derivate (s.Char) e.Op> : {
        empty = empty;
        eps = ('rep 'e.Op);
        e.Else = <ConcatSimplify (e.Else) ('rep 'e.Op)>;
    };
    (s.Char) ('con 'e.R1' 'e.R2)
    , <GetArguments ('con 'e.R1' 'e.R2)> : (e.R1^) e.R2^
*    , <Prout r1 '(con 'e.R1' 'e.R2') = ' e.R1> :
    , <L e.R1> : {
        True = <OrSimplify
                    (<ConcatSimplify
                        (<Derivate (s.Char) e.R1>)
                        e.R2>)
                    <Derivate (s.Char) e.R2>>;
        False = <ConcatSimplify
                    (<Derivate (s.Char) e.R1>)
                    e.R2>;
    };
    (s.Char) ('or 'e.R1' 'e.R2)
    , <GetArguments ('or 'e.R1' 'e.R2)> : (e.R1^) e.R2^
    = <OrSimplify
        (<Derivate (s.Char) e.R1>)
        <Derivate (s.Char) e.R2>>;
    (s.Char) ('sfl 'e.R1' 'e.R2)
    , <GetArguments ('or 'e.R1' 'e.R2)> : (e.R1^) e.R2^
    = <OrSimplify
        (<ShuffleSimplify
            (<Derivate (s.Char) e.R1>)
            e.R2>)
        <ShuffleSimplify
            (e.R1)
            <Derivate (s.Char) e.R2>>
        >;
}

ComputeDeriv {
    s.Char e.Vars (e.Expr) (e.LastChar)
    , <Cp 'Automata'> : t.Automata
    , <Derivate (s.Char) e.Expr> : {
        empty = ;
        e.Expr
        , <SymTable-InsertByState t.Automata (loop by s.Char' 'of e.LastChar) e.Expr> : t.Automata^
        , <Br 'Automata='t.Automata> :
        =;
        e.Deriv
        , <SymTable-InsertByState t.Automata (e.LastChar s.Char) e.Deriv> : t.Automata^
        , <Br 'Automata='t.Automata> :
        =
        <ComputeDeriv s.Char e.Vars (e.Deriv) (s.Char e.LastChar)>
        <ComputeDeriv e.Vars (e.Expr) ()>
        <ComputeDeriv e.Vars (e.Deriv) (s.Char)>
    };
    (e.Expr) (e.LastChar) = ;
}

L {
    eps = True;
    s.Char = False;
    ('rep 'e.Some) = True;
    ('con 'e.R1' 'e.R2)
    , <GetArguments ('con 'e.R1' 'e.R2)> : (e.R1^) e.R2
     = <And (<L e.R1>) <L e.R2>>;
    ('or 'e.R1' 'e.R2)
    , <GetArguments ('or 'e.R1' 'e.R2)> : (e.R1^) e.R2
     = <Or (<L e.R1>) <L e.R2>>;
}

GetArguments {
    (e.Op' '(e.R1)' 'e.R2)
    = ((e.R1)) e.R2;
    (e.Op' 'e.R1' '(e.R2))
    = (e.R1) (e.R2);
    (e.Op' '(e.R1)' '(e.R2))
    = ((e.R1)) (e.R2);
    (e.Op' 'e.R1' 'e.R2)
    = (e.R1) e.R2;
}

ShuffleSimplify {
    (e.R) eps = e.R;
    (eps) e.R = e.R;
    (e.R) empty = empty;
    (empty) e.R = empty;
    '(con 'e.A' 'e.R1') (con 'e.B' 'e.R2'))'
        = '(or '
            '(con 'e.A' (sfl 'e.R1' (con 'e.B' 'e.R2')))'
            '(con 'e.B' (sfl (con 'e.A' 'e.R1') 'e.R2'))'
           ')';
    (e.R1) e.R2 = '(sfl 'e.R1' 'e.R2')';

}

OrSimplify {
    (e.R) empty = e.R;
    (empty) e.R = e.R;
    (e.R1) e.R1 = e.R1;
    (e.R1) e.R2 = ('or 'e.R1' 'e.R2);
}

ConcatSimplify {
    (eps) e.R2 = e.R2;
    (e.R1) eps = e.R1;
    (empty) e.R2 = empty;
    (e.R1) empty = empty;
    (e.R1) e.R2 = ('con 'e.R1' 'e.R2);
}

And {
    (True) True = True;
    e.Else = False;
}

Or {
    (False) False = False;
    e.Else = True;
}