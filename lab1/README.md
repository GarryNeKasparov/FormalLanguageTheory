К сожалению, арифметика как-то муторно и плохо писалась. К тому же после всех подсчетов не очень
понятно, как парсить коэффиценты...

Но вот, что было придумано: вспомним алгебру и многочлены (финитные последовательности).
Пусть $`(a_0\;a_1...,\;a_i,\;...\;)`$ - вектор коэффицентов, при этом $a_i$ - суть коэффиценты при соответствующих степенях $w$ : $w^i * a_i$.

Тогда линейная функция $f$ с ординальными коэффицентами $w * a_1 + a_0$ представляется как $`(a_0,\;a_1)`$, где, конечно, 
подразумевается $`(a_1,\;a_0,\;0,\;0,\;...\;)`$.
А интерполяция имеет вид: $`F_0(x) = (a_0,\;a_1) * x + (b_0,\;b_1)`$.

Соответственно, правила: 
* $`k * (a_0,\;a_1,\;a_2,\;...\;) = (k * a_0,\;a_1,\;a_2,\;...\;)`$
* $`w * (a_0,\;a_1,\;a_2,\;...\;) = (0,\;a_0,\;a_1,\;a_2,\;...\;)`$ - просто сдвиг вправо!
* $`(a_0,\;a_1,\;a_2,\;...\;) * k = (a_0,\;a_1 * k,\;a_2 * k,\;...\;)`$
* $`(a_0,\;a_1,\;a_2,\;...\;) * w = (0,\;a_1,\;a_2,\;...\;)`$ - зануление свободного коэффицента
* $`(a_0,\;a_1) * (b_0,\;b_1,\;b_2,\;...,\;b_n) = (a_0,\;a_1) * b_0 + ((a_0,\;a_1) * w) * b1\;+\;...\;=\;(a_0,\;a_1*b_0,\;b_1,\;b_2,\;...,\;b_{n+1})`$

Плюс такого подхода, что коэффиценты легко определяются, не нужно следить за скобками, плюсами, умножениями...К тому же вместо работы с кучей арифметических
выражений - абстрагируемся до работы с двумя векторами.

Что ж! В теории звучит хорошо, а теперь за практику!

---
### Как это работает?
Скрипт **`test.cmd`**
``` cmd
CALL > %2
CALL > %3
CALL rlc main.ref > nul & main.exe %1 %2 > nul
CALL yices-smt2 %2 > %3
CALL rlc BuildAnswer.ref > nul & BuildAnswer.exe %3
CALL del %2 %3 main.exe BuildAnswer.exe
```
* запускается с тремя аргументами:
  * <i>путь/до/входа</i>
  * <i>путь/до/результата_программы</i>
  * <i>путь/до/результата_smt2</i>
* преобразует входные данные к smt2 формату;
* использует yices-smt солвер для решения системы;
* отдельная программа читает выход, полученный на предыдущем этапе, выводит ответ и строит интерполяции, если они существуют;

**Пример:** `test.cmd tests/1.txt tests/1_smt.smt2 tests/1_smt_out.txt`

**Вход:**
```
A -> C

```

**Вывод:** 
```
This SRS is terminated
A(x) = (w * 2 + 2) * x + (w * 1 + 2)
C(x) = (w * 1 + 1) * x + (w * 1 + 1)
```
---
**Пример:** `test.cmd tests\2.txt tests\2_smt.smt2 tests\2_smt_out.txt`

**Вход:**
```
A -> B
B -> A

```

**Вывод:**
```
This SRS is not terminated!
```
---

**Пример:** `test.cmd tests\3.txt tests\3_smt.smt2 tests\3_smt_out.txt`


**Вход:**
```
AB -> CD
CD -> FG
OP -> L

```

**Вывод:**
```
This SRS is terminated
B(x) = (w * 3 + 3) * x + (w * 2 + 2)
A(x) = (w * 3 + 1) * x + (w * 2 + 1)
D(x) = (w * 2 + 2) * x + (w * 1 + 1)
C(x) = (w * 2 + 1) * x + (w * 1 + 1)
P(x) = (w * 2 + 1) * x + (w * 1 + 1)
O(x) = (w * 2 + 1) * x + (w * 2 + 1)
G(x) = (w * 1 + 1) * x + (w * 1 + 1)
F(x) = (w * 1 + 1) * x + (w * 1 + 1)
L(x) = (w * 1 + 1) * x + (w * 1 + 1)
```
