К сожалению, арифметика как-то муторно и плохо писалась. К тому же после всех подсчетов не очень
понятно, как парсить коэффиценты...

Но вот, что было придумано: вспомним алгебру и многочлены (финитные последовательности).
Пусть $`(a_0\;a_1...,\;a_i,\;...\;)`$ - вектор коэффицентов, при этом $a_i$ - суть коэффиценты при соответствующих степенях $w$ : $w^i * a_i$.

Тогда линейная функция $f$ с ординальными коэффицентами $w * a_1 + a_0$ представляется как $`(a_0,\;a_1)`$, где, конечно, 
подразумевается $`(a_1,\;a_0,\;0,\;0,\;...\;)`$.
А интерполяция имеет вид: $`F_0(x) = (a_0,\;a_1) * x + (b_0,\;b_1)`$.

Соответственно, правила: 
* $`k * (a_0,\;a_1,\;a_2,\;...\;) = (k * a_0,\;a_1,\;a_2,\;...\;)`$
* $`w * (a_0,\;a_1,\;a_2,\;...\;) = (0,\;a_0,\;a_1,\;a_2,\;...\;)`$ - просто сдвиг вправо!
* $`(a_0,\;a_1,\;a_2,\;...\;) * k = (a_0,\;a_1 * k,\;a_2 * k,\;...\;)`$
* $`(a_0,\;a_1,\;a_2,\;...\;) * w = (0,\;a_1,\;a_2,\;...\;)`$ - зануление свободного коэффицента
* $`(a_0,\;a_1) * (b_0,\;b_1,\;b_2,\;...\;) = (a_0,\;a_1) * b_0 + ((a_0,\;a_1) * w) * b1 + ...`$

Плюс такого подхода, что коэффиценты легко определяются, не нужно следить за скобками, плюсами, умножениями...К тому же вместо работы с кучей арифметических
выражений - абстрагируемся до работы с двумя векторами.

Что ж! В теории звучит хорошо, а теперь за практику!

---
### Как это работает?
Скрипт **`test.cmd`**
``` cmd
CALL > %2
CALL > %3
CALL rlc main.ref > nul & main.exe %1 %2 > nul
CALL yices-smt2 %2 > %3
CALL rlc BuildAnswer.ref > nul & BuildAnswer.exe %3
CALL del %2 %3 main.exe BuildAnswer.exe
```
* запускается с тремя аргументами:
  * <i>путь/до/входа</i>
  * <i>путь/до/результата_программы</i>
  * <i>путь/до/результата_smt2</i>
