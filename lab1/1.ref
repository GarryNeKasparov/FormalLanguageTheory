$ENTRY Go {
    = <Prout <Solve './tests/1.txt' (1)>>;
*    = <Prout <OrdinalRules '(bA aA) * (bB aB)'>>;
}

Solve {
    e.File (s.Stream)
    , <Open 'r' s.Stream e.File> :
    , <ReadRules s.Stream () ()> : e.LeftRules' | 'e.RightRules
    , <Prout Rules ': ' e.LeftRules' | 'e.RightRules> :
    , <CreateInts e.LeftRules> :
    , <CreateInts e.RightRules> :
*    , <Dgall> : e.All
*    , <Prout e.All> :
    , <Generate (e.LeftRules) (e.RightRules) ()> : e.Res = e.Res;
}

Generate {
    (( )) (( )) (e.Res) = e.Res;
    (((e.LeftRule)e.LeftRules)) (((e.RightRule)e.RightRules)) (e.Res)
    , <Prout LeftRule e.LeftRule> :
    , <Prout RightRule e.RightRule> :
    , <CalcFunc (e.LeftRule) ()> : e.CalculatedLeft
    , <CalcFunc (e.RightRule) ()> : e.CalculatedRight =
        <Prout Left is e.CalculatedLeft ' | ' rest is e.LeftRules>
        <Prout Right is e.CalculatedRight ' | ' rest is e.RightRules>
        <Generate ((e.LeftRules)) ((e.RightRules)) (e.Res e.CalculatedLeft' | 'e.CalculatedRight' ')>;

}

CalcFunc {
    (e.First s.Func2 s.Func1) ()
    , <Prout first s.Func2 s.Func1> :
    , <Cp s.Func1> : e.Int1
    , <Cp s.Func2> : e.Int2
    , e.Int1 : '('e.X1' , 'e.Bias1')'
    , e.Int2 : '('e.X2' , 'e.Bias2')'
    , <Prout '('e.X2' , 'e.Bias2') * ('e.X1' , 'e.Bias1')'> :
    ,'('
            <OrdinalRules e.X2' * 'e.X1>' , '<OrdinalRules <OrdinalRules e.X2' * 'e.Bias1>' + 'e.Bias2>
      ')' : e.Calculated = <CalcFunc (e.First) (e.Calculated)>;
    ( ) (e.Calculated) = e.Calculated;

    (s.Func) () = <Prout second <Cp s.Func>> <Cp s.Func>;

    (s.Func) (e.Calculated)
    , <Cp s.Func> : e.Int
    , e.Int : '('e.X1' , 'e.Bias1')'
    , e.Calculated : '('e.X2' , 'e.Bias2')'
    , <Prout third '('e.X1' , 'e.Bias1')'' * ''('e.X2' , 'e.Bias2')'> : =
    '('
            <OrdinalRules e.X1' * 'e.X2>' , '<OrdinalRules <OrdinalRules e.X1' * 'e.Bias2>' + 'e.Bias1>
    ')';

    (e.First s.Func) (e.Calculated)
    , <Prout vierte> :
    , <Cp s.Func> : e.Int
    , e.Int : '('e.X1' , 'e.Bias1')'
    , e.Calculated : '('e.X2' , 'e.Bias2')'
    , '('<OrdinalRules
            <OrdinalRules e.X1' * 'e.X2>' + '<OrdinalRules e.X1' * 'e.Bias2>>' , 'e.Bias1
      ')' : e.Calculated2 = <CalcFunc (e.First) (e.Calculated2)>;
}

OrdinalRules {
    'w * 'e.Vect = <Shift e.Vect>;
    e.Vect' * w' = <MultVectorW e.Vect ()>;
    '('e.v0' 'e.v1') * 'e.Vect
    , <OrdinalRules 'w * '<OrdinalRules e.v1' * 'e.Vect>> : e.FirstMul
    , <OrdinalRules e.v0' * 'e.Vect> : e.SecondMul
        = <OrdinalRules e.FirstMul' + 'e.SecondMul>;
    e.Vect1' + 'e.Vect2 = <AddVector (e.Vect1) (e.Vect2) ()>;
    e.Koef' * 'e.Vect
    , e.Vect : e.Begin' 'e.Last = e.Begin'*'e.Koef' 'e.Last;
    e.Vect' * 'e.Koef = <MultVector (e.Vect) (e.Koef)>;
    e.Else = <Prout Not a rule'\n'> e.Else;
}

AddVector {
    ('('e.Begin1' 'e.Rest1) ('('e.Begin2' 'e.Rest2) () = <AddVector (e.Rest1) (e.Rest2) (e.Begin1'+'e.Begin2)>;
    (e.Begin1' 'e.Rest1) (e.Begin2' 'e.Rest2) (e.Res) = <AddVector (e.Rest1) (e.Rest2) (e.Res' 'e.Begin1'+'e.Begin2)>;
    (e.Begin1' 'e.Rest1')') (e.Last2')') (e.Res) = '('e.Res' 'e.Begin1'+'e.Last2' 'e.Rest1')';
    (e.Last1')') (e.Begin2' 'e.Rest2')') (e.Res) = '('e.Res' 'e.Last1'+'e.Begin2' 'e.Rest2')';
    (e.Last1')') (e.Last2')') (e.Res) = '('e.Res' 'e.Last1'+'e.Last2')';
    (e.1) (e.2) (e.Res) = <Prout e.1 e.2 (e.Res)>;
}

MultVectorW {
    '('e.First' 'e.Body () = <MultVectorW e.Body ('0 1')>;
    e.First' 'e.Body (e.Ans) = <MultVectorW e.Body (e.Ans' 1')>;
    e.Last')' (e.Ans) = '('e.Ans' 1)';
}

MultVector {
    (e.First' 'e.Rest) (e.Koef) = e.First'*'e.Koef' '<MultVector (e.Rest) (e.Koef)>;
    (e.First e.Rest')') (e.Koef) = e.First e.Rest'*'e.Koef')';
}

Shift {
    '('e.Vect')' = '(0 'e.Vect')';
}

CreateInts {
    ((e.Rule)e.RestRules) = <BuildFuncForString (e.Rule)> <CreateInts (e.RestRules)>;
    () = ;
}

BuildFuncForString {
    (s.F e.RestChars) = <BuildFunc s.F><BuildFuncForString (e.RestChars)>;
    ( ) = ;
}

BuildFunc {
    s.F
    , <Cp s.F> : {
                = <Br s.F '=' '((b's.F' a's.F') , (d's.F' c's.F'))'>;
        e.Found = ;
    };
}

ReadRules {
    s.Stream (e.LeftRules) (e.RightRules)
    , <Get s.Stream> : {
        0 = (e.LeftRules)' | '(e.RightRules);
        e.LeftRule' -> 'e.RightRule = <ReadRules s.Stream (e.LeftRules (e.LeftRule)) (e.RightRules (e.RightRule))>
    };
}
