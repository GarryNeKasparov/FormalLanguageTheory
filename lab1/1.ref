$ENTRY Go {
    = <Prout <Solve './tests/1.txt' (1)>>;
*    = <Prout <OrdinalRules '(2) + (2 . 2)'>>;
}

Solve {
    e.File (s.Stream)
    , <Open 'r' s.Stream e.File> :
    , <ReadRules s.Stream () ()> : e.LeftRules' | 'e.RightRules
    , <Prout Rules ': ' e.LeftRules' | 'e.RightRules> :
    , <CreateInts e.LeftRules> :
    , <CreateInts e.RightRules> :
*    , <Dgall> : e.All
*    , <Prout e.All> :
    , <Generate (e.LeftRules) (e.RightRules) ()> : e.Res = <ParseAnswer (e.Res)>;
}

Generate {
    (( )) (( )) (e.Res) = e.Res;
    (((e.LeftRule)e.LeftRules)) (((e.RightRule)e.RightRules)) ( )
*    , <Prout LeftRule e.LeftRule> :
*    , <Prout RightRule e.RightRule> :
    , <CalcFunc (e.LeftRule) ()> : e.CalculatedLeft
    , <CalcFunc (e.RightRule) ()> : e.CalculatedRight =
*        <Prout Left is e.CalculatedLeft ' | ' rest is e.LeftRules>
*        <Prout Right is e.CalculatedRight ' | ' rest is e.RightRules>
        <Generate ((e.LeftRules)) ((e.RightRules)) ('\n'e.CalculatedLeft' | 'e.CalculatedRight)>;

    (((e.LeftRule)e.LeftRules)) (((e.RightRule)e.RightRules)) (e.Res)
*    , <Prout LeftRule e.LeftRule> :
*    , <Prout RightRule e.RightRule> :
        , <CalcFunc (e.LeftRule) ()> : e.CalculatedLeft
        , <CalcFunc (e.RightRule) ()> : e.CalculatedRight =
*        <Prout Left is e.CalculatedLeft ' | ' rest is e.LeftRules>
*        <Prout Right is e.CalculatedRight ' | ' rest is e.RightRules>
            <Generate ((e.LeftRules)) ((e.RightRules)) (e.Res'\n'e.CalculatedLeft' | 'e.CalculatedRight)>;

}

CalcFunc {
    (e.First s.Func2 s.Func1) ()
*    , <Prout first s.Func2 s.Func1> :
    , <Cp s.Func1> : e.Int1
    , <Cp s.Func2> : e.Int2
    , e.Int1 : '('e.X1' , 'e.Bias1')'
    , e.Int2 : '('e.X2' , 'e.Bias2')'
*    , <Prout '('e.X2' , 'e.Bias2') * ('e.X1' , 'e.Bias1')'> :
    ,'('
            <OrdinalRules e.X2' * 'e.X1>' , '<OrdinalRules <OrdinalRules e.X2' * 'e.Bias1>' + 'e.Bias2>
      ')' : e.Calculated = <CalcFunc (e.First) (e.Calculated)>;
    ( ) (e.Calculated) = e.Calculated;

    (s.Func) () = <Cp s.Func>;

    (s.Func) (e.Calculated)
    , <Cp s.Func> : e.Int
    , e.Int : '('e.X1' , 'e.Bias1')'
    , e.Calculated : '('e.X2' , 'e.Bias2')' =
*    , <Prout third '('e.X1' , 'e.Bias1')'' * ''('e.X2' , 'e.Bias2')'> : =
    '('
            <OrdinalRules e.X1' * 'e.X2>' , '<OrdinalRules <OrdinalRules e.X1' * 'e.Bias2>' + 'e.Bias1>
    ')';

    (e.First s.Func) (e.Calculated)
*    , <Prout vierte> :
    , <Cp s.Func> : e.Int
    , e.Int : '('e.X1' , 'e.Bias1')'
    , e.Calculated : '('e.X2' , 'e.Bias2')'
    , '('<OrdinalRules
            <OrdinalRules e.X1' * 'e.X2>' + '<OrdinalRules e.X1' * 'e.Bias2>>' , 'e.Bias1
      ')' : e.Calculated2 = <CalcFunc (e.First) (e.Calculated2)>;
}

ParseAnswer {
    (e.Left' | 'e.Right'\n' e.Next) (e.Inequalities) = <ParseAnswer (e.Next) (e.Inequalities <GetInequalities (e.Left) (e.Right)>)>;
    e.l = ;
    ( ) (e.Conditions) = e.Conditions
}

GetInequalities {
    (( ) ( )) (e.Inequalities) = e.Inequalities;
    ((e.Left) (e.Right)) (e.Inequalities)
    , <First (e.Left)> : e.LF e.LR
    , <First (e.Right)> : e.RF e.RR
    , e.LF : {
         = <GetInequalities (e.Right) (e.Inequalities)>;
        e.NotEmptyL
        , e.RF : {
           () = <GetInequalities (e.Left) (e.Inequalities)>;
           e.NotEmptyR = <GetInequalities ((e.LR) (e.RR)) (e.Inequalities '(> 'e.LF e.RF')')>;
        };
    };
    (e.OnePart) (e.Inequalities)
    , <First (e.OnePart)> : e.OF e.OR
    , e.OF : {
         = e.Inequalities;
        e.NotEmpty = <GetInequalities ((e.OR)) (e.Inequalities '(> 'e.OF '0)')>;
    }
}

First {
    ('('e.Begin' . 'e.Rest) = (e.Begin)'('e.Rest;
    ('('e.Last')') = (e.Last);
    () = () ();

}

OrdinalRules {
    'w * 'e.Vect = <Shift e.Vect>;
    e.Vect' * w' = <MultVectorW (e.Vect)>;
    '('e.v0' . 'e.v1') * ('e.Vect')' = <MultVectorCord ('('e.v0' . 'e.v1')') (e.Vect)>;
    '('e.v0' . 'e.v1') * 'e.Koef = '('e.v0' . (* 'e.v1' 'e.Koef'))';
    e.Vect1' + 'e.Vect2 = <AddVector (e.Vect1) (e.Vect2) ()>;
    e.Koef' * ('e.Vect')'
    , e.Vect : e.Begin' . 'e.Last = '(* e.Begin' 'e.Koef) . 'e.Last;
*    e.Vect' * 'e.Koef = <MultVector (e.Vect) (e.Koef)>;
    e.Else = <Prout Not a rule e.Else'\n'> e.Else;
}

MultVectorCord {
    ('('e.v0' . 'e.v1')') (e.Vect)
    , <First ('('e.Vect')')> : (e.Koef) e.Rest
    , <Prout '('e.v0' . 'e.v1')*'e.Koef' = '<OrdinalRules '('e.v0' . 'e.v1') * 'e.Koef>> :
    , <Shift <Shift e.Rest>> : e.ShiftedRest
    , <OrdinalRules '('e.v0' . 'e.v1') * 'e.Koef> : e.MultKoef
    , <Prout e.ShiftedRest' + 'e.MultKoef> :
        = <OrdinalRules e.ShiftedRest' + 'e.MultKoef>;
}

SimplifyAdd {
    '(+ 'e.Begin1' 'e.Begin2')'
    , e.Begin1 : {
        '0' = e.Begin2;
        e.Else1
        , e.Begin2 : {
            '0' = e.Begin1;
            e.Else2 = '(+ 'e.Begin1' 'e.Begin2')';
        };
    };
}

AddVector {
    ('('e.Begin1' . 'e.Rest1) ('('e.Begin2' . 'e.Rest2) () = <AddVector (e.Rest1) (e.Rest2) (<SimplifyAdd '(+ 'e.Begin1' 'e.Begin2')'>)>;
    (e.Begin1' . 'e.Rest1) (e.Begin2' . 'e.Rest2) (e.Res) = <AddVector (e.Rest1) (e.Rest2) (e.Res' . '<SimplifyAdd '(+ 'e.Begin1' 'e.Begin2')'>)>;
    (e.Begin1' . 'e.Rest1')') (e.Last2')') (e.Res) = '('e.Res' . '<SimplifyAdd '(+ 'e.Begin1' 'e.Last2')'>' . 'e.Rest1')';
    (e.Last1')') (e.Begin2' . 'e.Rest2')') (e.Res) = '('e.Res' . '<SimplifyAdd '(+ 'e.Last1' 'e.Begin2')'>' . 'e.Rest2')';
    (e.Last1')') (e.Last2')') (e.Res) = '('e.Res' . '<SimplifyAdd '(+ 'e.Last1' 'e.Last2')'>')';
*    (e.Vec1) (e.Vec2) ()
*        , <First (e.Vec1)> : (e.Koef1) e.Rest1
*        , <First (e.Vec2)> : (e.Koef2) e.Rest2
*        , e.Koef1 : {
*             = (e.Rest2);
*            e.NotEmpty1
*            , <Prout e.NotEmpty1> :
*            , e.Koef2 : {
*                 = (e.Rest1);
*                e.NotEmpty2 = <AddVector (e.Rest1) (e.Rest2) (e.Koef1'+'e.Koef2)>;
*            };
*        };
*
*    (e.Vec1) (e.Vec2) (e.Res)
*    , <First (e.Vec1)> : (e.Koef1) e.Rest1
*    , <First (e.Vec2)> : (e.Koef2) e.Rest2
*    , e.Koef1 : {
*         , e.Rest2 : {
*            = (e.Res);
*           e.else =  (e.Res' . 'e.else);
*         };
*        e.NotEmpty1
*        , <Prout e.NotEmpty1> :
*        , e.Koef2 : {
*             , e.Rest1 : {
*                = (e.Res);
*               e.else = (e.Res' . 'e.else);
*             };
*            e.NotEmpty2
*            , <Prout lo e.NotEmpty2> : = <AddVector (e.Rest1) (e.Rest2) (e.Res' . 'e.Koef1'+'e.Koef2)>;
*        };
*    };
    (e.1) (e.2) (e.Res) = <Prout no need for this line (e.Res)> e.Res;
}

MultVectorW {
    ('('e.First' . 'e.Body) = '(0 . 'e.Body;
}

MultVector {
    (e.First' . 'e.Rest) (e.Koef) = e.First'*'e.Koef' '<MultVector (e.Rest) (e.Koef)>;
    (e.First e.Rest')') (e.Koef) = e.First e.Rest'*'e.Koef')';
}

Shift {
    '('e.Vect')' = '(0 . 'e.Vect')';
}

CreateInts {
    ((e.Rule)e.RestRules) = <BuildFuncForString (e.Rule)> <CreateInts (e.RestRules)>;
    () = ;
}

BuildFuncForString {
    (s.F e.RestChars) = <BuildFunc s.F><BuildFuncForString (e.RestChars)>;
    ( ) = ;
}

BuildFunc {
    s.F
    , <Cp s.F> : {
                = <Br s.F '=' '((b's.F' . a's.F') , (d's.F' . c's.F'))'>;
        e.Found = ;
    };
}

ReadRules {
    s.Stream (e.LeftRules) (e.RightRules)
    , <Get s.Stream> : {
        0 = (e.LeftRules)' | '(e.RightRules);
        e.LeftRule' -> 'e.RightRule = <ReadRules s.Stream (e.LeftRules (e.LeftRule)) (e.RightRules (e.RightRule))>
    };
}
