*$FROM LibraryEx
*$EXTERN Map;

$ENTRY Go {
*    = <Solve './tests/1.txt' (1)>;
    = <Prout
        <OrdinalRules '(3 2) * (2 1)'>
       >;
}

Solve {
    e.File (s.Stream)
    , <Open 'r' s.Stream e.File> :
    , <ReadRules s.Stream ()> : e.Rules
    , <Prout Rules ': ' e.Rules> :
    , <CreateInts e.Rules> : = <Prout <Dg 'A'>'\n'<Dg 'B'>'\n'<Dg 'C'>>;
}




OrdinalRules {
    'w * 'e.Vect = <Shift e.Vect>;
    e.Vect' * w' = <MultVectorW e.Vect ()>;
    '('t.v1' 't.v0') * 'e.Vect = <Prout t.v1' * 'e.Vect>
    <OrdinalRules 'w * '<OrdinalRules t.v1' * 'e.Vect>>' + '
    <OrdinalRules t.v0' * 'e.Vect>;
    e.Koef' * 'e.Vect
    , e.Vect : e.Begin' 'e.Last')'
    , e.Last : {
        '0' = e.Begin' 'e.Koef')';
        e.NotNull = e.Begin' 'e.Last'*'e.Koef')';
    };


    e.Vect' * 'e.Koef = <MultVector (e.Vect) (e.Koef)>;
    e.Else = <Prout Not a rule'\n'> e.Else;
}

MultVectorW {
    '('e.First' 'e.Vect () = <MultVectorW e.Vect (1 1)>;
    e.First' 'e.Body (e.Ans) = <MultVectorW e.Body (e.Ans 1)>;
    e.Last')' (e.Ans) = (e.Ans '0');

}

MultVector {
*    ('('e.First' 'e.Rest')') (e.Koef) = (e.First'*'e.Koef' '<MultVector (e.Rest) (e.Koef)>);
    (e.First' 'e.Rest) (e.Koef) = e.First'*'e.Koef' '<MultVector (e.Rest) (e.Koef)>;
    (e.First e.Rest')') (e.Koef) = e.First e.Rest'*'e.Koef')';
}

Shift {
    e.Vect
    , e.Vect : e.Begin' 'e.Last')' = e.Begin' 'e.Last' 0)';
}




/*
OrdinalArithm {
    (ord e.K1)' * '(ord e.K2) = <Prout 4 ((ord e.K1)' * '(ord e.K2))> (ord ord e.K2);
    (ord e.K1)' * 'e.B1 = <Prout 3 ((ord e.K1)' * 'e.B1)> (ord e.K1' * 'e.B1);
    (e.Number' + '(ord e.K1)) = <Prout 1 (e.Number' + '(ord e.K1))> (ord e.K1);
    (e.Number' * '(ord e.K1)) = <Prout 2 (e.Number' * '(ord e.K1))> (ord e.K1);


    e.Mult1' * 'e.Mult2
    , <Prout e.Mult1' tut 'e.Mult2> :
    , <OrdinalArithm (e.Mult1)> : {
        (e.Add1' + 'e.Add2) = <Prout parse1 e.Add1' 'plus e.Add2>
        (<OrdinalArithm (<OrdinalArithm e.Add1>)' * '(<OrdinalArithm e.Mult2>)>)' + '
        (<OrdinalArithm (<OrdinalArithm e.Add2>)' * '(<OrdinalArithm e.Mult2>)>);
        e.NoAdd1
        , <OrdinalArithm e.Mult2> : {
            (e.Add3' + 'e.Add4) = <Prout parse2 e.Add3' 'plus e.Add4>
                (<OrdinalArithm <OrdinalArithm (e.NoAdd1)>' * '<OrdinalArithm (e.Add3)>>)' + '
                (<OrdinalArithm <OrdinalArithm (e.NoAdd1)>' * '<OrdinalArithm (e.Add4)>>);
            e.NoAdd2 = <Prout last e.NoAdd1' * 'e.NoAdd2>
             e.NoAdd1' * 'e.NoAdd2;
            };
     };
    e.e = <Prout no e.e>  e.e;

}
*/

CreateInts {
    s.F = <Prout s.F> <BuildFunc s.F>;
    s.F e.RestRules = <Prout s.F> <BuildFunc s.F> <CreateInts e.RestRules>;
}

BuildFunc {
    s.F = <Br s.F '=' '(a's.F' b's.F') , (c's.F' d's.F')'>;
}

ReadRules {
    s.Stream (e.Rules)
    , <Get s.Stream> : e.Rule
    , e.Rule : {
        0 = e.Rules;
        e.NotNull = <ReadRules s.Stream (e.Rules e.Rule)>;
    }
}
