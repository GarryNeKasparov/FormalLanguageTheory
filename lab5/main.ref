*$FROM LibraryEx
$EXTERN Map;
*$FROM Set
$EXTERN Set-Create, Set-Insert, Set-Isin, Set-InsertList, Set-Get;
*$FROM List
$EXTERN List-Create, List-InitForEach, List-Rewrite, List-DropKey,
List-Append, List-AppendList, List-Get, List-ToJSON, List-Keys, List-WhereIn;

$ENTRY Go {
    , <Open 'r' 1 <Arg 1>> :
    , <ReadLines 1 ('#grammar')> : '#priority\n'e.Priority'\n#string\n'e.String
    , <ParseGrammar 1> : t.Grammar
*    , <Prout <List-ToJSON t.Grammar>> :
    , <RemoveUseless t.Grammar> : t.Grammar^

*    , <Prout <List-ToJSON t.Grammar>> :
    , <ConstructFIRST t.Grammar> : t.FIRST
    , <Prout <List-ToJSON t.FIRST>> :
    , <ConstructFOLLOW t.Grammar> : t.FOLLOW
    , <Prout <List-ToJSON t.FOLLOW>> :
*    , <Prout <Closure t.Grammar>> :

    = <Close 1>;
}

Closure_loop {
    t.Grammar t.Items /*empty*/
    = t.Items;
    t.Grammar t.Items (e.a'.'e.y)e.Items
    , e.y : {
        s.y' 'e.ye = s.y;
        s.y e.ye '\'' ' 'e.yye = s.y e.ye '\'';
    } : e.y^
    , <List-Get t.Grammar e.y> : {
        /*empty*/ = ;
        e.L = <Set-InsertList t.Items e.L>;
    };
}

Closure_ {
    t.Grammar t.Items
    , <Closure_loop t.Grammar t.Items <Set-Get t.Items>> : {
        t.Items = t.Items;
        t.NewItems = <Closure_loop t.Grammar t.NewItems <Set-Get t.NewItems>>;
    };
}

Closure {
    t.Grammar
    , <Set-Create> : t.Items
    , <List-Keys t.Grammar> : (e.Start)e.Keys
    , <Set-Insert t.Items 'S\' -> .'e.Start> : t.Items^
    = <Closure t.Grammar t.Items>;
}


FindWithoutT_termsloop {
    e.T' 'e.TE
    , <IsNTerm e.T> : {
        True = True;
        False = <FindWithoutT_termsloop e.TE>;
    };
    e.T
    , <IsNTerm e.T> : {
        True = True;
        False = False;
    }
}

FindWithoutT_ruleloop {
    /*empty*/ = True;
    (e.Rule)e.Rules
*    , <Prout e.Rule> :
    , <FindWithoutT_termsloop e.Rule> : {
        True = <FindWithoutT_ruleloop e.Rules>;
        False = False;
    }
}

FindWithoutT {
    t.Grammar t.Set /*empty*/
    = t.Set;
    t.Grammar t.Set (e.K)e.Keys
    , <List-Get t.Grammar e.K> : e.Rules
    , <FindWithoutT_ruleloop e.Rules> : {
        False = <FindWithoutT t.Grammar <Set-Insert t.Set e.K> e.Keys>;
        True = <FindWithoutT t.Grammar t.Set e.Keys>;
    }
}

RemoveUseless_termsloop {
    t.Set e.T' 'e.TE
    , <IsNTerm e.T> : {
        True
        , <Set-Isin t.Set e.T> : {
            True = True;
            False = <RemoveUseless_termsloop t.Set e.TE>;
        };
        False = <RemoveUseless_termsloop t.Set e.TE>;
    };
    t.Set e.T
    , <IsNTerm e.T> : {
        True
        , <Set-Isin t.Set e.T> : {
            True = True;
            False = False;
        };
        False = False;
    }
}

RemoveUseless_ruleloop {
    t.Set /*empty*/
    = False;
    t.Set (e.Rule)e.Rules
    , <RemoveUseless_termsloop t.Set e.Rule> : {
        True = True;
        False = <RemoveUseless_ruleloop t.Set e.Rules>;
    }
}

RemoveUseless_loop {
    t.Grammar t.Set /*empty*/
    = t.Set;
    t.Grammar t.Set (e.K)e.Keys
    , <List-Get t.Grammar e.K> : e.Rules
    , <RemoveUseless_ruleloop t.Set e.Rules> : {
        True = <RemoveUseless_loop t.Grammar <Set-Insert t.Set e.K> e.Keys>;
        False = <RemoveUseless_loop t.Grammar t.Set e.Keys>;
    };
}

RemoveUseless_ {
    t.Grammar t.Set
    , <FindWithoutT t.Grammar t.Set <List-Keys t.Grammar>> : t.Set^
    , <List-Keys t.Grammar> : e.Keys
    , <RemoveUseless_loop t.Grammar t.Set e.Keys> : {
        t.Set = t.Set;
        t.NewSet = <RemoveUseless_loop t.Grammar t.NewSet e.Keys>;
    }
}

RemoveUseless {
    t.Grammar
    , <Set-Create> : t.Set
    , <RemoveUseless_ t.Grammar t.Set> : t.Set^
    , <Prout t.Set> :
    = <DropFromGrammar t.Grammar t.Set <List-Keys t.Grammar>>;
}

DropFromGrammar_termsloop {
    t.Set e.T' 'e.TE
    , <IsNTerm e.T> : {
        True
        , <Set-Isin t.Set e.T> : {
            True = <DropFromGrammar_termsloop t.Set e.TE>;
            False = False;
        };
        False = <DropFromGrammar_termsloop t.Set e.TE>;
    };
    t.Set e.T
    , <IsNTerm e.T> : {
        True
        , <Set-Isin t.Set e.T> : {
            True = True;
            False = False;
        };
        False = True;
    }
}

DropFromGrammar_ruleloop {
    t.Set /*empty*/
    = ;
    t.Set (e.Rule)e.Rules
    , <DropFromGrammar_termsloop t.Set e.Rule> : {
        True = (e.Rule)<DropFromGrammar_ruleloop t.Set e.Rules>;
        False = <DropFromGrammar_ruleloop t.Set e.Rules>;
    }
}

DropFromGrammar {
    t.Grammar t.Set /*empty*/
    = t.Grammar;
    t.Grammar t.Set (e.K)e.Keys
    , <List-Get t.Grammar e.K> : e.Rules
    , <DropFromGrammar_ruleloop t.Set e.Rules> : {
        /*empty*/ = <List-DropKey t.Grammar e.K>;
        e.Rules^ = <List-Rewrite t.Grammar (e.K) e.Rules>;
    } : t.Grammar^
    = <DropFromGrammar t.Grammar t.Set e.Keys>;
}

Split {
    (e.Delimeter) e.SB' 'e.Delimeter' 'e.SE
    = (e.SB)<Split (e.Delimeter) e.SE>;
    (e.Delimeter) e.S
    = (e.S);

}

ParseGrammar_ {
    t.List s.Stream
    , <Get s.Stream> : {
        0 = t.List;
        e.T' -> 'e.Rule 0 = <List-AppendList t.List (e.T) <Split ('|') e.Rule>>;
        e.T' -> 'e.Rule = <ParseGrammar_ <List-AppendList t.List (e.T) <Split ('|') e.Rule>> s.Stream>;
    }
}

ParseGrammar {
    s.Stream
    , <List-Create> : t.List
    = <ParseGrammar_ t.List s.Stream>;
}

FIRST {
    t.Grammar e.T' 'e.TE
    , <IsNTerm e.T> : {
        True
        , <List-Get t.Grammar e.T> : e.Rules
        = <Map {
            (e.T' 'e.TE) = ; /*ignoring A -> AX rules*/
            (e.Rule) = <FIRST t.Grammar e.Rule>;
            } e.Rules>;
        False = (e.T)
    };
    t.Grammar e.T
    , <IsNTerm e.T> : {
        True
        , <List-Get t.Grammar e.T> : e.Rules
        = <Map {
            (e.T' 'e.TE) = ; /*ignoring A -> AX rules*/
            (e.Rule) = <FIRST t.Grammar e.Rule>;
            } e.Rules>;
        False = (e.T);
    }
}


FIRST_rulesloop {
    t.Grammar t.Set /*empty*/
    = t.Set;
    t.Grammar t.Set (e.Rule)e.Rules
    , <Prout e.Rule> :
    , <Prout <FIRST t.Grammar e.Rule>> :

    , <Set-InsertList t.Set <FIRST t.Grammar e.Rule>> : t.Set^
    = <FIRST_rulesloop t.Grammar t.Set e.Rules>;
}

FIRST_loop {
    t.Grammar t.FIRST /*empty*/
    , <Dg 'changed'> : {
        'True' = <Br 'changed=False'><Prout hi><FIRST_loop t.Grammar t.FIRST <List-Keys t.Grammar>>;
        'False' = t.FIRST;
    };
    t.Grammar t.FIRST (e.K)e.Keys
    , <List-Get t.Grammar e.K> : e.Rules
    , <List-Get t.FIRST e.K> : (t.Set)
    , <FIRST_rulesloop t.Grammar t.Set e.Rules> : {
        t.Set = t.Set;
        t.NewSet = <Br 'changed=True'>t.NewSet;
    } : t.Set^
    , <Prout (e.K)t.Set> :

    , <List-Rewrite t.FIRST (e.K) (t.Set)> : t.FIRST^
    = <FIRST_loop t.Grammar t.FIRST e.Keys>;
}

FIRST_InitList {
    t.FIRST /*empty*/
    = t.FIRST;
    t.FIRST (e.N)e.NT
    = <FIRST_InitList <List-Append t.FIRST (e.N) <Set-Create>> e.NT>;
}

ConstructFIRST {
    t.Grammar
    , <List-Create> : t.FIRST
    , <List-Keys t.Grammar> : e.NT
    , <FIRST_InitList t.FIRST e.NT> : t.FIRST^
    , <Br 'changed=False'> :
    = <FIRST_loop t.Grammar t.FIRST <List-Keys t.Grammar>>;

}


ContainsTerm {
    (e.T)
    = <ContainsTerm e.T>;
    e.T' 'e.TE
    , <IsNTerm e.T> : {
        True = <ContainsTerm e.TE>;
        False = True;
    };
    e.T
    , <IsNTerm e.T> : {
        True = False;
        False = True;
    };
}

Eq {
    e.E (e.E) = True;
    e.E (e.S) = False;
}

OR {
    (False) False = False;
    e.E = True;
}

FOLLOW_ruleloop {
    t.Grammar t.FOLLOW (e.K) /*empty*/
    = t.FOLLOW;
    t.Grammar t.FOLLOW (e.K) e.X
    , e.X : {
        e.B' 'e.XE = e.B(e.XE);
        e.B = e.B();
    } : e.X^(e.XE)
    , <Prout (e.X)' rest 'e.XE> :
    , <IsNTerm e.X> : {
        False = <FOLLOW_ruleloop t.Grammar t.FOLLOW (e.K) e.XE>;
        True
        , <List-Get t.FOLLOW e.X> : (t.XF)
        , t.XF : t.XFC
        , <FIRST t.Grammar e.XE> : e.FST
        , <Set-InsertList t.XF e.FST> : t.XF^
        , <OR (<ContainsTerm e.FST>) <Eq e.FST ()>> : {
            True
            , <List-Get t.FOLLOW e.K> : (t.KF)
            , <Set-Get t.KF> : (e.KF)
            , <Prout want t.XF' 'e.KF' got '<Set-InsertList t.XF e.KF>> :
            = <Set-InsertList t.XF e.KF>;
            False
            = t.XF;
        } : t.XF^
        , <Prout (e.X)' 't.XF> :
        , t.XF : {
            t.XFC = <FOLLOW_ruleloop t.Grammar t.FOLLOW (e.K) e.XE>;
            t.NXF
            , <Prout NEW t.FOLLOW> :
            , <Br 'changed=True'> :
            , <List-Rewrite t.FOLLOW (e.X) (t.NXF)> : t.FOLLOW^
            , <Prout t.FOLLOW>  :
            = <FOLLOW_ruleloop t.Grammar t.FOLLOW (e.K) e.XE>;
        }
    }
}

FOLLOW_rulesloop {
    t.Grammar t.FOLLOW (e.K) /*empty*/
    = t.FOLLOW;
    t.Grammar t.FOLLOW (e.K) (e.Rule)e.Rules
    , <FOLLOW_ruleloop t.Grammar t.FOLLOW (e.K) e.Rule> : t.FOLLOW^
    = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
    /*
    t.Grammar t.FOLLOW (e.K) (e.a' 'e.B' 'e.y)e.Rules
    , <Prout three (e.K)' '(e.a)e.B(e.y)> :
    , <IsNTerm e.B> : {
        False = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
        True
        , <List-Get t.FOLLOW e.B> : (t.BF)
        , t.BF : t.BFC
        , <FIRST t.Grammar e.y> : e.Fst
        , <ContainsTerm e.Fst> : {
            False = t.BF;
            True
            , <List-Get t.FOLLOW e.K> : (t.KF)
            , <Set-Get t.KF> : e.KF
            = <Set-InsertList t.BF e.KF>;
        } : t.BF^
*        , <Prout t.BF e.Fst> :
        , <Set-InsertList t.BF e.Fst> : t.BF^
*        , <Prout t.BF> :
        , t.BF : {
            t.BFC = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
            t.NewF
            , <List-Rewrite t.FOLLOW (e.B) (t.BF)> : t.FOLLOW^
            = <Br 'changed=True'><FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
        };
    };

    t.Grammar t.FOLLOW (e.K) (e.a' 'e.B)e.Rules
    , <Prout two> :
    , <IsNTerm e.a> : {
        False
        , <IsNTerm e.B> : {
            False = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
            True
            , <Prout tut (e.a' 'e.B)> :
            , <List-Get t.FOLLOW e.B> : (t.BF)
*            , <Prout t.BF' '(e.B)> :
            , <List-Get t.FOLLOW e.K> : (t.KF)
            , <Set-Get t.KF> : (e.KF)
            , <Set-InsertList t.BF e.KF> : t.BF^
            , <List-Rewrite t.FOLLOW (e.B) (t.BF)> : {
                t.FOLLOW = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
                t.NEWFOLLOW = <Br 'changed=True'><FOLLOW_rulesloop t.Grammar t.NEWFOLLOW (e.K) e.Rules>;
            };
        };
        True
        , <List-Get t.FOLLOW e.a> : (t.BF)

        , t.BF : t.BFC
        , <FIRST t.Grammar e.B> : e.Fst
        , <Prout lol t.BF' '(e.B)> :
        , <ContainsTerm e.Fst> : {
            False = t.BF;
            True
            , <List-Get t.FOLLOW e.K> : (t.KF)
            , <Set-Get t.KF> : (e.KF)
            , <Prout t.KF' 'e.KF' 'want <Set-InsertList t.BF e.KF>> :
            = <Set-InsertList t.BF e.KF>;
        } : t.BF^
        , <Prout t.BF e.Fst' 'pol> :
        , <Set-InsertList t.BF e.Fst> : t.BF^
*        , <Prout finish t.BF> :
        , t.BF : {
            t.BFC = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
            t.NewF
            , <List-Rewrite t.FOLLOW (e.a) (t.BF)> : t.FOLLOW^
            = <Br 'changed=True'><FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
        };

    };

    t.Grammar t.FOLLOW (e.K) (e.a)e.Rules
    , <IsNTerm e.a> : {
        False = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
        True
        , <List-Get t.FOLLOW e.a> : (t.BF)
        , <List-Get t.FOLLOW e.K> : (t.KF)
        , <Set-Get t.KF> : (e.KF)
        , <Set-InsertList t.BF e.KF> : t.BF^
        , <List-Rewrite t.FOLLOW (e.a) (t.BF)> : {
            t.FOLLOW = <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules>;
            t.NEWFOLLOW = <Br 'changed=True'><FOLLOW_rulesloop t.Grammar t.NEWFOLLOW (e.K) e.Rules>;
        };
    };
    */

}

FOLLOW_loop {
    t.Grammar t.FOLLOW /*empty*/
*    , <Prout tut> :
    , <Dg 'changed'> : {
        'False' = t.FOLLOW;
        'True' = <Prout <List-ToJSON t.FOLLOW>><Br 'changed=False'><FOLLOW_loop t.Grammar t.FOLLOW <List-Keys t.Grammar>>;
    };
    t.Grammar t.FOLLOW (e.K)e.Keys
    , <Prout e.K> :
    , <List-Get t.Grammar e.K> : e.Rules
    , <FOLLOW_rulesloop t.Grammar t.FOLLOW (e.K) e.Rules> : t.FOLLOW^
    = <FOLLOW_loop t.Grammar t.FOLLOW e.Keys>;
}

FOLLOW_InitList {
    t.FOLLOW /*empty*/
    = t.FOLLOW;
    t.FOLLOW (e.S) (e.S)e.NT
    , <Set-Create> : t.Set
    , <Set-Insert t.Set f> : t.Set^
    = <FOLLOW_InitList <List-Append t.FOLLOW (e.S) t.Set> e.NT>;
    t.FOLLOW (e.N)e.NT
    = <FOLLOW_InitList <List-Append t.FOLLOW (e.N) <Set-Create>> e.NT>;
}

ConstructFOLLOW {
    t.Grammar
    , <List-Create> : t.FOLLOW
    , <List-Keys t.Grammar> : (e.S)e.NT
    , <FOLLOW_InitList t.FOLLOW (e.S) (e.S)e.NT> : t.FOLLOW^
    , <Br 'changed=False'> :
*    , <Prout <List-Keys t.Grammar>> :
    = <FOLLOW_loop t.Grammar t.FOLLOW (e.S)e.NT>;
}

IsNTerm {
    s.A
    , <Compare (<Ord s.A>) <Ord 'Z'>> : {
        '-'
        , <Compare (<Ord s.A>) <Ord 'A'>> : {
            '-' = False;
            s.E = True;
        };
        s.E = False;
    };
    e.T = True; /*S''''...'*/
}

ReadLines {
    s.Stream (e.Stop)
    , <Get s.Stream> : {
        e.Line 0 = e.Line;
        e.Stop = ;
        e.Line = e.Line'\n'<ReadLines s.Stream (e.Stop)>;
    }
}